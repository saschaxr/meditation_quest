{"version":3,"file":"vircadia-audio-output.js","mappings":"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","sources":["webpack://@vircadia/web-sdk/./src/domain/worklets/AudioOutputProcessor.ts"],"sourcesContent":["//\n//  AudioOutputProcessor.ts\n//\n//  Created by David Rowe on 14 Sep 2021.\n//  Copyright 2021 Vircadia contributors.\n//  Copyright 2021 DigiSomni LLC.\n//\n//  Distributed under the Apache License, Version 2.0.\n//  See the accompanying file LICENSE or http://www.apache.org/licenses/LICENSE-2.0.html\n//\n\n\n/*@devdoc\n *  The <code>AudioOutputProcessor</code> class implements a Web Audio\n *  {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletProcessor|AudioWorkletProcessor} that outputs SDK audio\n *  to a MediaStream. It is used as a node in a Web Audio graph in {@link AudioOutput}.\n *  <p>It runs on its own thread and uses a ring buffer to buffer an amount of data received to play in order to help maintain a\n *  smooth output stream.</p>\n *  <p>C++: <code>N/A</code></p>\n *  @class AudioOutputProcessor\n *  @param {AudioWorkletNodeOptions} options -\n *    {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletProcessor/AudioWorkletProcessor|AudioWorkletProcessor}\n *    options.\n *\n *  @property {MessagePort} port - Used to communicate between the AudioWorkletProcessor object and its internal code. See\n *    {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioWorkletNode/port|AudioWorkletNode.port}.\n */\nclass AudioOutputProcessor extends AudioWorkletProcessor {\n\n    // Buffer blocks of audio data so that they can be played back smoothly.\n    // FIXME: All these fields should be private (#s) but Firefox isn't handling transpiled code with them (Sep 2021).\n    _audioBuffer: Int16Array[] = [];\n    // MAX_AUDIO_BUFFER_LENGTH = AudioClient.#RECEIVED_AUDIO_STREAM_CAPACITY_BLOCKS\n    readonly MAX_AUDIO_BUFFER_LENGTH = 360;  // The maximum number of audio blocks to buffer\n    readonly MIN_AUDIO_BUFFER_LENGTH = 180;  // The minimum number of audio blocks to have before starting to play them.\n    _isPlaying = false;  // Is playing audio blocks from the buffer.\n    _haveLoggedOverflow = false;\n\n\n    constructor(options?: AudioWorkletNodeOptions) {\n        super(options);\n\n        this.port.onmessage = this.onMessage;\n    }\n\n\n    /*@devdoc\n     *  Takes incoming audio blocks posted to the audio worklet's message port and queues them in a ring buffer for playing.\n     *  If too many audio blocks are queued, some of the older ones are discarded.\n     *  If too few audio blocks are queued, playing is paused while a minimum number of audio blocks are accumulated.\n     *  The number of audio blocks buffered is posted on the message port.\n     *  @function AudioOutputProcessor.onMessage\n     *  @param {MessageEvent} message - The message posted to the audio worklet, with <code>message.data</code> being an\n     *      <code>Int16Array</code> of PCM audio samples, ready to play.\n     */\n    onMessage = (message: MessageEvent) => {\n        // Buffer the new block of audio samples.\n        const audioBlock = new Int16Array(message.data);\n        this._audioBuffer.push(audioBlock);\n\n        // If we've surpassed the maximum buffer size, skip some older audio blocks.\n        if (this._audioBuffer.length > this.MAX_AUDIO_BUFFER_LENGTH) {\n            // The incoming audio stream should be <= the rate of consumption so only skip the minimum number of blocks.\n            while (this._audioBuffer.length > this.MAX_AUDIO_BUFFER_LENGTH) {\n                this._audioBuffer.shift();\n            }\n            if (!this._haveLoggedOverflow) {\n                console.log(\"AudioOutputProcessor: Buffer overflowed.\");\n                this._haveLoggedOverflow = true;\n            }\n        }\n\n        // Start playing if not playing and we now have enough audio blocks.\n        if (!this._isPlaying && this._audioBuffer.length >= this.MIN_AUDIO_BUFFER_LENGTH) {\n            // console.log(\"AudioOutputProcessor: Start playing.\");\n            this._isPlaying = true;\n        }\n\n        // Report the number of audio blocks buffered.\n        this.port.postMessage(this._audioBuffer.length);\n    };\n\n\n    /*@devdoc\n     *  Called by the Web Audio pipeline to provide the next block of audio samples to play. The next audio block from the ring\n     *  buffer is played if one is available and playing is not paused, otherwise a block of silence is played. The Int32 values\n     *  from the ring buffer are converted to Float32 values.\n     *  @param {Float32Array[][]} inputList - Input PCM audio samples. <em>Not used.</em>\n     *  @param {Float32Array[][]} outputList - Output PCM audio samples.\n     *  @param {Record<string, Float32Array>} parameters - Processing parameters. <em>Not used.</em>\n     *  @returns {boolean} <code>true</code> to keep the processor node alive.\n     */\n    // eslint-disable-next-line\n    // @ts-ignore\n    process(inputList: Float32Array[][], outputList: Float32Array[][] /* , parameters: Record<string, Float32Array> */) {\n\n        const FLOAT_TO_INT = 32767;\n\n        // Grab the next block of audio to play.\n        let audioBlock: Int16Array | undefined = undefined;\n        if (this._isPlaying) {\n            audioBlock = this._audioBuffer.shift();\n            this.port.postMessage(this._audioBuffer.length);\n            if (audioBlock === undefined) {\n                // console.log(\"AudioOutputProcessor: Stop playing.\");\n                this._isPlaying = false;\n                this._haveLoggedOverflow = false;\n            }\n        }\n\n        if (!outputList || !outputList[0] || !outputList[0][0] || !outputList[0][1]) {\n            return true;\n        }\n\n        const channelCount = 2;\n        const EXPECTED_AUDIO_BLOCK_FRAMES = 128;\n        const sampleCount = Math.min(outputList[0][0].length, audioBlock ? audioBlock.length / 2 : EXPECTED_AUDIO_BLOCK_FRAMES);\n\n        const output = outputList[0];\n        for (let channel = 0; channel < channelCount; channel++) {\n            const samples = output[channel] as Float32Array;\n            for (let i = 0; i < sampleCount; i++) {\n                let sample = 0;\n                if (audioBlock) {\n                    sample = audioBlock[i * 2 + channel] as number / FLOAT_TO_INT;\n                }\n                samples[i] = sample;\n            }\n        }\n\n        return true;\n    }\n}\n\nregisterProcessor(\"vircadia-audio-output-processor\", AudioOutputProcessor);\n"],"names":[],"sourceRoot":""}